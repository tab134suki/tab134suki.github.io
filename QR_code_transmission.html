<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äºŒç»´ç æ–‡ä»¶ä¼ è¾“å·¥å…· (ECC)</title>
    <!-- åŠ è½½å¤–éƒ¨åº“ -->
    <script src="https://cdn.bootcdn.net/ajax/libs/elliptic/6.6.1/elliptic.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/kjua@0.10.0/dist/kjua.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --success-color: #27ae60;
            --error-color: #e74c3c;
            --bg-color: #ecf0f1;
            --text-color: #2c3e50;
            --border-radius: 8px;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 20px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: #fff;
            border-radius: var(--border-radius);
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px;
            text-align: center;
        }
        nav {
            display: flex;
            background-color: #34495e;
        }
        nav button {
            flex: 1;
            padding: 15px;
            border: none;
            background: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        nav button:hover, nav button.active {
            background-color: var(--secondary-color);
        }
        main {
            padding: 20px;
        }
        section { display: none; }
        section.active { display: block; }
        h2 { margin-top: 0; color: var(--primary-color); border-bottom: 2px solid var(--secondary-color); padding-bottom: 10px; }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, textarea, select, button {
            width: 100%;
            padding: 10px;
            border: 1px solid #bdc3c7;
            border-radius: var(--border-radius);
            font-size: 16px;
        }
        button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover { background-color: #2980b9; }
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        .status { padding: 10px; border-radius: var(--border-radius); margin-top: 10px; }
        .status.info { background-color: #d6eaf8; border-left: 5px solid var(--secondary-color); }
        .status.success { background-color: #d5f5e3; border-left: 5px solid var(--success-color); }
        .status.error { background-color: #fadbd8; border-left: 5px solid var(--error-color); }
        #slideshow-container {
            text-align: center;
            margin: 20px 0;
        }
        #qr-slideshow {
            max-width: 100%;
            height: auto;
            border: 2px solid var(--primary-color);
            border-radius: var(--border-radius);
        }
        #video-container {
            text-align: center;
            margin: 20px 0;
        }
        #video-preview {
            max-width: 100%;
            height: auto;
            border: 2px solid var(--primary-color);
            border-radius: var(--border-radius);
        }
        #scan-progress {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        #received-files-list, #sent-files-list {
            list-style: none;
            padding: 0;
        }
        .file-item {
            padding: 10px;
            border: 1px solid #bdc3c7;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
            background-color: #f8f9fa;
        }
        .file-item a {
            display: inline-block;
            margin-top: 5px;
            padding: 5px 10px;
            background-color: var(--success-color);
            color: white;
            text-decoration: none;
            border-radius: 4px;
            font-size: 14px;
        }
        .file-item a:hover {
            background-color: #219653;
        }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }
        .card {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: var(--border-radius);
            overflow-x: auto;
            white-space: pre-wrap;
        }
        footer {
            text-align: center;
            padding: 20px;
            background-color: #34495e;
            color: white;
            font-size: 14px;
        }
        @media (max-width: 768px) {
            nav { flex-direction: column; }
            .grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ”’ äºŒç»´ç æ–‡ä»¶ç¦»çº¿ä¼ è¾“å·¥å…· (ECC)</h1>
            <p>åŸºäº secp256r1 æ¤­åœ†æ›²çº¿åŠ å¯†ï¼Œçº¯å‰ç«¯å®ç°</p>
        </header>
        <nav>
            <button id="nav-send" class="active" onclick="switchView('view-send')">ğŸ“¤ å‘é€æ–‡ä»¶</button>
            <button id="nav-receive" onclick="switchView('view-receive')">ğŸ“¥ æ¥æ”¶æ–‡ä»¶</button>
            <button id="nav-keys" onclick="switchView('view-keys')">ğŸ”‘ å¯†é’¥ç®¡ç†</button>
            <button id="nav-storage" onclick="switchView('view-storage')">ğŸ’¾ æœ¬åœ°å­˜å‚¨</button>
        </nav>
        <main>
            <!-- å‘é€æ–‡ä»¶è§†å›¾ -->
            <section id="view-send" class="active">
                <h2>ğŸ“¤ å‘é€æ–‡ä»¶</h2>
                <div class="grid">
                    <div class="card">
                        <h3>1. é…ç½®ä¸ä¸Šä¼ </h3>
                        <div class="form-group">
                            <label for="sender-private-key-select">é€‰æ‹©å‘é€ç§é’¥ (Index 0-A):</label>
                            <select id="sender-private-key-select">
                                <option value="">-- ä»å­˜å‚¨ä¸­é€‰æ‹© --</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="sender-private-key">æˆ–è¾“å…¥ç§é’¥:</label>
                            <textarea id="sender-private-key" rows="3" placeholder="è¯·è¾“å…¥æ‚¨çš„ 64 ä½åå…­è¿›åˆ¶ç§é’¥..."></textarea>
                        </div>
                        <div class="form-group">
                            <label for="sender-files">é€‰æ‹©æ–‡ä»¶ (æœ€å¤š25ä¸ª):</label>
                            <input type="file" id="sender-files" multiple accept="*/*">
                        </div>
                        <div class="form-group">
                            <label for="chunk-size">å—å¤§å° (KB):</label>
                            <input type="number" id="chunk-size" value="100" min="1">
                        </div>
                        <div class="form-group">
                            <label for="display-speed">å¹»ç¯ç‰‡é€Ÿåº¦ (QR/s):</label>
                            <input type="number" id="display-speed" value="2" min="1" max="10">
                        </div>
                        <button id="process-btn">âš™ï¸ å¤„ç†å¹¶åŠ å¯†æ–‡ä»¶</button>
                        <div id="sender-status" class="status info">è¯·å…ˆé…ç½®å¯†é’¥å¹¶é€‰æ‹©æ–‡ä»¶ã€‚</div>
                    </div>
                    <div class="card">
                        <h3>2. ç”ŸæˆäºŒç»´ç </h3>
                        <div id="slideshow-container">
                            <p>å¤„ç†å®Œæˆåï¼ŒäºŒç»´ç å°†æ˜¾ç¤ºåœ¨è¿™é‡Œã€‚</p>
                            <img id="qr-slideshow" style="display:none;" alt="QR Code Slideshow">
                        </div>
                        <button id="start-slideshow-btn" disabled>â–¶ï¸ å¼€å§‹å¹»ç¯ç‰‡</button>
                        <button id="stop-slideshow-btn" disabled>â¹ï¸ åœæ­¢å¹»ç¯ç‰‡</button>
                        <p id="slideshow-info"></p>
                    </div>
                </div>
                <div class="card">
                    <h3>å·²å¤„ç†çš„æ–‡ä»¶</h3>
                    <ul id="sent-files-list"></ul>
                </div>
            </section>

            <!-- æ¥æ”¶æ–‡ä»¶è§†å›¾ -->
            <section id="view-receive">
                <h2>ğŸ“¥ æ¥æ”¶æ–‡ä»¶</h2>
                <div class="grid">
                    <div class="card">
                        <h3>1. æ‰«æè®¾ç½®</h3>
                        <div class="form-group">
                            <label for="receiver-private-key-select">é€‰æ‹©æ¥æ”¶ç§é’¥:</label>
                            <select id="receiver-private-key-select">
                                <option value="">-- ä»å­˜å‚¨ä¸­é€‰æ‹© --</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="receiver-private-key">æˆ–è¾“å…¥ç§é’¥:</label>
                            <textarea id="receiver-private-key" rows="3" placeholder="è¯·è¾“å…¥æ‚¨çš„ 64 ä½åå…­è¿›åˆ¶ç§é’¥..."></textarea>
                        </div>
                        <button id="start-scan-btn">ğŸ“· å¼€å§‹æ‰«ææ‘„åƒå¤´</button>
                        <button id="stop-scan-btn" disabled>ğŸ›‘ åœæ­¢æ‰«æ</button>
                        <div id="receiver-status" class="status info">è¯·å…ˆé…ç½®å¯†é’¥å¹¶å¯åŠ¨æ‰«æã€‚</div>
                    </div>
                    <div class="card">
                        <h3>2. æ‰«æé¢„è§ˆä¸è¿›åº¦</h3>
                        <div id="video-container">
                            <video id="video-preview" autoplay muted playsinline style="display:none;"></video>
                            <p id="no-camera-msg">æ‘„åƒå¤´æœªå¯åŠ¨æˆ–æ— ä¿¡å·ã€‚</p>
                        </div>
                        <div id="scan-progress">
                            <span>å·²æ‰«æ: <span id="scanned-count">0</span></span>
                            <span>é€Ÿåº¦: <span id="scan-speed">0</span> Kb/s</span>
                        </div>
                        <div id="scan-progress-bar-container" style="width:100%; background-color:#ddd; border-radius:5px; margin-top:10px;">
                            <div id="scan-progress-bar" style="width:0%; height:20px; background-color:var(--success-color); border-radius:5px; transition: width 0.3s;"></div>
                        </div>
                    </div>
                     <!-- æ–°å¢å¡ç‰‡ï¼šä¸Šä¼ äºŒç»´ç å›¾ç‰‡ -->
                     <div class="card">
                        <h3>3. ä¸Šä¼ äºŒç»´ç å›¾ç‰‡</h3>
                        <div class="form-group">
                            <label for="qr-image-upload">é€‰æ‹©äºŒç»´ç å›¾ç‰‡æ–‡ä»¶:</label>
                            <input type="file" id="qr-image-upload" accept="image/*" multiple>
                            <p><small>æ”¯æŒ PNG, JPG, JPEG, GIF, WEBP ç­‰å›¾ç‰‡æ ¼å¼ã€‚</small></p>
                        </div>
                        <button id="process-qr-images-btn">ğŸ“¸ å¤„ç†é€‰ä¸­çš„å›¾ç‰‡</button>
                        <div id="upload-qr-status" class="status info">è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶å¹¶ç‚¹å‡»å¤„ç†ã€‚</div>
                    </div>
                </div>
                <div class="card">
                    <h3>å·²æ¥æ”¶çš„æ–‡ä»¶</h3>
                    <ul id="received-files-list"></ul>
                </div>
            </section>

            <!-- å¯†é’¥ç®¡ç†è§†å›¾ -->
            <section id="view-keys">
                <h2>ğŸ”‘ å¯†é’¥ç®¡ç†</h2>
                <div class="grid">
                    <div class="card">
                        <h3>æ·»åŠ /ç¼–è¾‘å¯†é’¥</h3>
                        <div class="form-group">
                            <label for="key-name">å¯†é’¥åç§°:</label>
                            <input type="text" id="key-name" placeholder="ä¾‹å¦‚: MyKey_A">
                        </div>
                        <div class="form-group">
                            <label for="key-value">ç§é’¥ (64ä½åå…­è¿›åˆ¶):</label>
                            <textarea id="key-value" rows="3" placeholder="è¯·è¾“å…¥æ‚¨çš„ç§é’¥..."></textarea>
                        </div>
                        <div class="form-group">
                            <label for="key-index">å…³è”æ–‡ä»¶ID (A-Y):</label>
                            <select id="key-index">
                                <option value="">-- é€‰æ‹© --</option>
                                <!-- A-Y options will be populated by JS -->
                            </select>
                        </div>
                        <button id="save-key-btn">ğŸ’¾ ä¿å­˜å¯†é’¥</button>
                        <button id="clear-keys-btn" style="background-color: var(--error-color);">ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰å¯†é’¥</button>
                    </div>
                    <div class="card">
                        <h3>å·²å­˜å‚¨çš„å¯†é’¥</h3>
                        <ul id="stored-keys-list"></ul>
                    </div>
                </div>
            </section>

            <!-- æœ¬åœ°å­˜å‚¨è§†å›¾ -->
            <section id="view-storage">
                <h2>ğŸ’¾ æœ¬åœ°å­˜å‚¨</h2>
                <div class="card">
                    <h3>å­˜å‚¨ä¿¡æ¯</h3>
                    <p>æ­¤å·¥å…·ä½¿ç”¨ <code>localStorage</code> (å°æ•°æ®) å’Œ <code>IndexedDB</code> (å¤§æ•°æ®å¦‚äºŒç»´ç å›¾ç‰‡ã€æ–‡ä»¶) æ¥å­˜å‚¨æ•°æ®ã€‚</p>
                    <button id="clear-storage-btn" style="background-color: var(--error-color);">ğŸ§¨ æ¸…é™¤æ‰€æœ‰æœ¬åœ°æ•°æ®</button>
                    <div id="storage-info"></div>
                </div>
                <div class="card">
                    <h3>è°ƒè¯•ä¿¡æ¯</h3>
                    <details>
                        <summary>ç‚¹å‡»æŸ¥çœ‹/éšè—</summary>
                        <pre id="debug-info">æš‚æ— è°ƒè¯•ä¿¡æ¯</pre>
                    </details>
                </div>
            </section>
        </main>
        <footer>
            <p>çº¯å‰ç«¯å®ç°ï¼Œæ•°æ®ä¸ç¦»å¼€æ‚¨çš„æµè§ˆå™¨ã€‚åŸºäºæ‚¨çš„æ–‡æ¡£è¦æ±‚æ„å»ºã€‚</p>
        </footer>
    </div>

    <script>
        // --- åº”ç”¨çŠ¶æ€ç®¡ç† ---
        const AppState = {
            currentView: 'view-send',
            sender: {
                privateKey: null,
                files: [],
                processedChunks: [],
                slideshowInterval: null,
                currentSlideIndex: 0
            },
            receiver: {
                privateKey: null,
                stream: null,
                scanning: false,
                receivedChunks: {}, // { fileId: { total, chunks: {index: {data, ephemeralPubKey, fileHash}} } }
                scanCount: 0,
                lastScanTime: 0,
                totalExpected: 0
            },
            keys: JSON.parse(localStorage.getItem('ecc_keys') || '{}')
        };

        // --- DOM å…ƒç´ ç¼“å­˜ ---
        const DOM = {
            // Navigation
            navSend: document.getElementById('nav-send'),
            navReceive: document.getElementById('nav-receive'),
            navKeys: document.getElementById('nav-keys'),
            navStorage: document.getElementById('nav-storage'),
            // Views
            viewSend: document.getElementById('view-send'),
            viewReceive: document.getElementById('view-receive'),
            viewKeys: document.getElementById('view-keys'),
            viewStorage: document.getElementById('view-storage'),
            // Sender
            senderPrivateKeySelect: document.getElementById('sender-private-key-select'),
            senderPrivateKey: document.getElementById('sender-private-key'),
            senderFiles: document.getElementById('sender-files'),
            chunkSize: document.getElementById('chunk-size'),
            displaySpeed: document.getElementById('display-speed'),
            processBtn: document.getElementById('process-btn'),
            senderStatus: document.getElementById('sender-status'),
            qrSlideshow: document.getElementById('qr-slideshow'),
            startSlideshowBtn: document.getElementById('start-slideshow-btn'),
            stopSlideshowBtn: document.getElementById('stop-slideshow-btn'),
            slideshowInfo: document.getElementById('slideshow-info'),
            sentFilesList: document.getElementById('sent-files-list'),
            // Receiver
            receiverPrivateKeySelect: document.getElementById('receiver-private-key-select'),
            receiverPrivateKey: document.getElementById('receiver-private-key'),
            startScanBtn: document.getElementById('start-scan-btn'),
            stopScanBtn: document.getElementById('stop-scan-btn'),
            receiverStatus: document.getElementById('receiver-status'),
            videoPreview: document.getElementById('video-preview'),
            noCameraMsg: document.getElementById('no-camera-msg'),
            scannedCount: document.getElementById('scanned-count'),
            scanSpeed: document.getElementById('scan-speed'),
            scanProgressBar: document.getElementById('scan-progress-bar'),
            receivedFilesList: document.getElementById('received-files-list'),
            // æ–°å¢ DOM å…ƒç´ 
            qrImageUpload: document.getElementById('qr-image-upload'),
            processQrImagesBtn: document.getElementById('process-qr-images-btn'),
            uploadQrStatus: document.getElementById('upload-qr-status'),
            // Keys
            keyName: document.getElementById('key-name'),
            keyValue: document.getElementById('key-value'),
            keyIndex: document.getElementById('key-index'),
            saveKeyBtn: document.getElementById('save-key-btn'),
            clearKeysBtn: document.getElementById('clear-keys-btn'),
            storedKeysList: document.getElementById('stored-keys-list'),
            // Storage
            clearStorageBtn: document.getElementById('clear-storage-btn'),
            storageInfo: document.getElementById('storage-info'),
            debugInfo: document.getElementById('debug-info')
        };

        // --- UI æ›´æ–°å‡½æ•° ---
        function switchView(viewId) {
            // Hide all views
            document.querySelectorAll('section').forEach(section => section.classList.remove('active'));
            // Show selected view
            document.getElementById(viewId).classList.add('active');
            // Update nav active state
            document.querySelectorAll('nav button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`nav-${viewId.split('-')[1]}`).classList.add('active');
            AppState.currentView = viewId;
            logDebug(`åˆ‡æ¢åˆ°è§†å›¾: ${viewId}`);
        }

        function updateStatus(element, message, type = 'info') {
            element.textContent = message;
            element.className = `status ${type}`;
            logDebug(`çŠ¶æ€æ›´æ–° [${type}]: ${message}`);
        }

        function populateKeySelects() {
            DOM.senderPrivateKeySelect.innerHTML = '<option value="">-- ä»å­˜å‚¨ä¸­é€‰æ‹© --</option>';
            DOM.receiverPrivateKeySelect.innerHTML = '<option value="">-- ä»å­˜å‚¨ä¸­é€‰æ‹© --</option>';
            for (const name in AppState.keys) {
                const option = new Option(name, name);
                DOM.senderPrivateKeySelect.add(option.cloneNode(true));
                DOM.receiverPrivateKeySelect.add(option.cloneNode(true));
            }
        }

        function populateKeyIndexSelect() {
            DOM.keyIndex.innerHTML = '<option value="">-- é€‰æ‹© --</option>';
            for (let i = 0; i < 25; i++) {
                const letter = String.fromCharCode(65 + i);
                const option = new Option(`${letter} (Index ${i})`, i.toString());
                DOM.keyIndex.add(option);
            }
        }

        function updateSentFilesList() {
            const list = DOM.sentFilesList;
            list.innerHTML = '';
            const item = document.createElement('li');
            item.className = 'file-item';
            item.innerHTML = '<p>å¤„ç†åçš„æ–‡ä»¶å’ŒäºŒç»´ç ä¼šä¸´æ—¶å­˜å‚¨åœ¨æµè§ˆå™¨ä¸­ã€‚</p>';
            list.appendChild(item);
        }

        function updateReceivedFilesList() {
            const list = DOM.receivedFilesList;
            list.innerHTML = '';
            
            // ä» localStorage è·å–å·²æ¥æ”¶æ–‡ä»¶çš„å…ƒæ•°æ®
            const receivedMeta = JSON.parse(localStorage.getItem('received_files_meta') || '{}');
            
            if (Object.keys(receivedMeta).length === 0) {
                const item = document.createElement('li');
                item.className = 'file-item';
                item.innerHTML = '<p>æš‚æ— å·²æ¥æ”¶çš„æ–‡ä»¶ã€‚</p>';
                list.appendChild(item);
                return;
            }

            for (const fileId in receivedMeta) {
                const meta = receivedMeta[fileId];
                const item = document.createElement('li');
                item.className = 'file-item';
                item.innerHTML = `
                    <strong>${meta.name}</strong> (${(meta.size / 1024).toFixed(2)} KB)
                    <br>SHA256: <small>${meta.sha256.substring(0, 256)}...</small>
                    <br>æ¥æ”¶æ—¶é—´: ${new Date(meta.timestamp).toLocaleString()}
                    <a href="#" data-file-id="${fileId}" class="download-link">ğŸ’¾ ä¸‹è½½</a>
                `;
                list.appendChild(item);
            }

            // ç»‘å®šä¸‹è½½äº‹ä»¶
            document.querySelectorAll('.download-link').forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    const fileId = this.getAttribute('data-file-id');
                    downloadReceivedFile(fileId);
                });
            });
        }

        function updateStoredKeysList() {
            const list = DOM.storedKeysList;
            list.innerHTML = '';
            for (const name in AppState.keys) {
                const key = AppState.keys[name];
                const item = document.createElement('li');
                item.className = 'file-item';
                item.innerHTML = `
                    <strong>${name}</strong>
                    <br>å…³è”ID: ${String.fromCharCode(65 + parseInt(key.index))}
                    <br>å€¼: <small>${key.value.substring(0, 16)}...</small>
                    <button data-key-name="${name}" class="delete-key-btn" style="background-color:var(--error-color); margin-top:5px;">åˆ é™¤</button>
                `;
                list.appendChild(item);
            }
            
            // ç»‘å®šåˆ é™¤äº‹ä»¶
            document.querySelectorAll('.delete-key-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const keyName = this.getAttribute('data-key-name');
                    deleteKey(keyName);
                });
            });
        }

        function updateStorageInfo() {
            const lsSize = JSON.stringify(localStorage).length;
            const info = `localStorage ä½¿ç”¨: ~${(lsSize / 1024).toFixed(2)} KB`;
            DOM.storageInfo.innerHTML = `<p>${info}</p><p>IndexedDB å­˜å‚¨äºŒç»´ç å’Œæ–‡ä»¶ (å¤§å°ä¸åœ¨æ­¤æ˜¾ç¤º)ã€‚</p>`;
        }

        function logDebug(message) {
            const time = new Date().toISOString();
            const logEntry = `[${time}] ${message}\n`;
            const currentLog = DOM.debugInfo.textContent;
            DOM.debugInfo.textContent = logEntry + currentLog;
        }

        // --- å¯†é’¥ç®¡ç† ---
        function saveKey() {
            const name = DOM.keyName.value.trim();
            const value = DOM.keyValue.value.trim();
            const index = DOM.keyIndex.value;

            if (!name || !value || !index) {
                alert("è¯·å¡«å†™æ‰€æœ‰å­—æ®µã€‚");
                return;
            }
            if (!/^[0-9a-fA-F]{64}$/.test(value)) {
                alert("ç§é’¥å¿…é¡»æ˜¯64ä½åå…­è¿›åˆ¶å­—ç¬¦ä¸²ã€‚");
                return;
            }

            AppState.keys[name] = { value, index };
            localStorage.setItem('ecc_keys', JSON.stringify(AppState.keys));
            updateStatus(DOM.senderStatus, `å¯†é’¥ '${name}' å·²ä¿å­˜ã€‚`, 'success');
            populateKeySelects();
            updateStoredKeysList();
            logDebug(`å¯†é’¥å·²ä¿å­˜: ${name}`);
        }

        function deleteKey(name) {
            if (confirm(`ç¡®å®šè¦åˆ é™¤å¯†é’¥ '${name}' å—?`)) {
                delete AppState.keys[name];
                localStorage.setItem('ecc_keys', JSON.stringify(AppState.keys));
                updateStoredKeysList();
                populateKeySelects();
                logDebug(`å¯†é’¥å·²åˆ é™¤: ${name}`);
            }
        }

        function clearAllKeys() {
            if (confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å­˜å‚¨çš„å¯†é’¥å—?")) {
                AppState.keys = {};
                localStorage.removeItem('ecc_keys');
                updateStoredKeysList();
                populateKeySelects();
                logDebug("æ‰€æœ‰å¯†é’¥å·²æ¸…ç©ºã€‚");
            }
        }

        // --- å‘é€ç«¯é€»è¾‘ ---
        async function handleProcessFiles() {
            const files = DOM.senderFiles.files;
            if (files.length === 0) {
                updateStatus(DOM.senderStatus, "è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªæ–‡ä»¶ã€‚", 'error');
                return;
            }
            if (files.length > 25) {
                updateStatus(DOM.senderStatus, "æœ€å¤šåªèƒ½é€‰æ‹©25ä¸ªæ–‡ä»¶ã€‚", 'error');
                return;
            }

            const privKeyHex = DOM.senderPrivateKey.value.trim();
            if (!privKeyHex || !/^[0-9a-fA-F]{64}$/.test(privKeyHex)) {
                updateStatus(DOM.senderStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„64ä½åå…­è¿›åˆ¶ç§é’¥ã€‚", 'error');
                return;
            }
            AppState.sender.privateKey = privKeyHex;

            const chunkSizeKb = parseInt(DOM.chunkSize.value) || 100;
            const displaySpeed = parseInt(DOM.displaySpeed.value) || 2;
            const delayMs = Math.round(1000 / displaySpeed);

            updateStatus(DOM.senderStatus, "æ­£åœ¨å¤„ç†æ–‡ä»¶...", 'info');
            DOM.processBtn.disabled = true;

            try {
                // 1. æ’åºæ–‡ä»¶å¹¶åˆ†é…ID (A-Y)
                const fileArray = Array.from(files);
                fileArray.sort((a, b) => b.size - a.size);
                const fileIds = {};
                fileArray.forEach((file, index) => {
                    if (index < 25) { // é™åˆ¶åœ¨ A-Y
                        fileIds[file.name] = String.fromCharCode(65 + index);
                    }
                });

                // 2. å¤„ç†æ¯ä¸ªæ–‡ä»¶
                AppState.sender.processedChunks = [];
                // let totalChunks = 0; // ä¸å†éœ€è¦å…¨å±€è®¡æ•°ï¼Œæ¯ä¸ªæ–‡ä»¶æœ‰è‡ªå·±çš„æ€»å—æ•°
                for (const file of fileArray) {
                    const fileId = fileIds[file.name];
                    if (!fileId) continue; // è·³è¿‡è¶…å‡ºèŒƒå›´çš„æ–‡ä»¶

                    const arrayBuffer = await file.arrayBuffer();
                    const base64Content = arrayBufferToBase64(arrayBuffer);
                    const fileHash = await calculateSHA256(arrayBuffer); // åŸå§‹æ–‡ä»¶ SHA256
                    const fileType = file.type || 'unknown';
                    const fileName = file.name;
                    // --- æå–æ–‡ä»¶åå’Œåç¼€ ---
                    const lastDotIndex = fileName.lastIndexOf('.');
                    const baseFileName = lastDotIndex > 0 ? fileName.substring(0, lastDotIndex) : fileName;
                    const fileExtension = lastDotIndex > 0 ? fileName.substring(lastDotIndex + 1) : '';
                    // ---

                    const chunks = splitString(base64Content, chunkSizeKb * 1024);
                    // totalChunks += chunks.length; // ä¸å†ç´¯åŠ å…¨å±€æ€»æ•°

                    // --- ä¸ºå½“å‰æ–‡ä»¶åˆ›å»ºå…ƒæ•°æ®å­—ç¬¦ä¸² ---
                    // æ ¼å¼: ORIGINAL_FILENAME|ORIGINAL_EXTENSION|ORIGINAL_SHA256|TOTAL_CHUNKS
                    const fileMetaDataString = `${baseFileName}|${fileExtension}|${fileHash}|${chunks.length}`;
                    const fileMetaDataB64 = arrayBufferToBase64(new TextEncoder().encode(fileMetaDataString));
                    // ---

                    for (let i = 0; i < chunks.length; i++) {
                        const chunkIndex = i + 1;
                        // --- å°†æ–‡ä»¶æ•°æ®å’Œå…ƒæ•°æ®ç»„åˆåå†åŠ å¯† ---
                        // æ ¼å¼: CHUNK_BASE64_DATA|FILE_METADATA_B64
                        const dataToEncrypt = `${chunks[i]}|${fileMetaDataB64}`;
                        const encryptedResult = await encryptDataWithECC(dataToEncrypt, privKeyHex); // encryptDataWithECC éœ€è¦èƒ½å¤„ç†è¿™ä¸ªç»„åˆå­—ç¬¦ä¸²
                        // ---
                        
                        // --- æ ¹æ®æ–‡æ¡£æ ¼å¼åŒ–äºŒç»´ç æ•°æ® ---
                        // æ ¼å¼: <EPHEMERAL_PUBKEY_HEX>-<ENCRYPTED_COMBINED_DATA_B64>-<CHUNK_ID>-<ORIGINAL_FILE_SHA256>-<TOTAL_CHUNKS>
                        const qrDataStr = formatQRData(
                            encryptedResult.encryptedDataB64, // åŠ å¯†åçš„ç»„åˆæ•°æ®
                            fileId,
                            chunkIndex,
                            chunks.length, // å½“å‰æ–‡ä»¶çš„æ€»å—æ•°
                            encryptedResult.ephemeralPublicKeyHex,
                            fileHash // åŸå§‹æ–‡ä»¶ SHA256
                        );

                        AppState.sender.processedChunks.push({
                            dataStr: qrDataStr,
                            fileId: fileId,
                            index: chunkIndex
                        });
                    }
                }

                // 3. ç”ŸæˆäºŒç»´ç  (ç®€åŒ–ï¼šåªæ˜¾ç¤ºç¬¬ä¸€ä¸ª)
                if (AppState.sender.processedChunks.length > 0) {
                    const firstChunkData = AppState.sender.processedChunks[0].dataStr;
                    generateAndDisplayQR(firstChunkData);
                    DOM.startSlideshowBtn.disabled = false;
                    DOM.slideshowInfo.textContent = `å…±å¤„ç† ${AppState.sender.processedChunks.length} ä¸ªå—ã€‚é€Ÿåº¦: ${delayMs} ms/å—ã€‚`;
                    updateStatus(DOM.senderStatus, `æ–‡ä»¶å¤„ç†å®Œæˆã€‚`, 'success');
                } else {
                    throw new Error("æœªç”Ÿæˆä»»ä½•æ•°æ®å—ã€‚");
                }

            } catch (error) {
                console.error("å¤„ç†æ–‡ä»¶æ—¶å‡ºé”™:", error);
                updateStatus(DOM.senderStatus, `å¤„ç†å¤±è´¥: ${error.message}`, 'error');
            } finally {
                DOM.processBtn.disabled = false;
            }
        }

        function generateAndDisplayQR(dataStr) {
            try {
                const qrCanvas = kjua({
                    render: 'canvas',
                    crisp: true,
                    minVersion: 1,
                    ecLevel: 'L',
                    size: 300,
                    ratio: 2, // For retina screens
                    fill: '#333',
                    back: '#fff',
                    text: dataStr,
                    rounded: 0,
                    quiet: 1,
                    mode: 'plain'
                });
                DOM.qrSlideshow.src = qrCanvas.toDataURL('image/png');
                DOM.qrSlideshow.style.display = 'inline-block';
                logDebug("äºŒç»´ç å·²ç”Ÿæˆå¹¶æ˜¾ç¤ºã€‚");
            } catch (e) {
                console.error("ç”ŸæˆäºŒç»´ç å¤±è´¥:", e);
                updateStatus(DOM.senderStatus, `ç”ŸæˆäºŒç»´ç å¤±è´¥: ${e.message}`, 'error');
            }
        }

        function startSlideshow() {
            if (AppState.sender.processedChunks.length === 0) return;

            stopSlideshow(); // ç¡®ä¿ä¹‹å‰æ²¡æœ‰è¿è¡Œ
            const displaySpeed = parseInt(DOM.displaySpeed.value) || 2;
            const delayMs = Math.round(1000 / displaySpeed);

            AppState.sender.currentSlideIndex = 0;
            DOM.slideshowInfo.textContent = `å¹»ç¯ç‰‡æ’­æ”¾ä¸­... (${AppState.sender.currentSlideIndex + 1}/${AppState.sender.processedChunks.length})`;

            AppState.sender.slideshowInterval = setInterval(() => {
                AppState.sender.currentSlideIndex = (AppState.sender.currentSlideIndex + 1) % AppState.sender.processedChunks.length;
                const currentChunk = AppState.sender.processedChunks[AppState.sender.currentSlideIndex];
                generateAndDisplayQR(currentChunk.dataStr);
                DOM.slideshowInfo.textContent = `å¹»ç¯ç‰‡æ’­æ”¾ä¸­... (${AppState.sender.currentSlideIndex + 1}/${AppState.sender.processedChunks.length})`;
            }, delayMs);

            DOM.startSlideshowBtn.disabled = true;
            DOM.stopSlideshowBtn.disabled = false;
            updateStatus(DOM.senderStatus, "å¹»ç¯ç‰‡å·²å¼€å§‹æ’­æ”¾ã€‚", 'info');
        }

        function stopSlideshow() {
            if (AppState.sender.slideshowInterval) {
                clearInterval(AppState.sender.slideshowInterval);
                AppState.sender.slideshowInterval = null;
            }
            DOM.startSlideshowBtn.disabled = false;
            DOM.stopSlideshowBtn.disabled = true;
            updateStatus(DOM.senderStatus, "å¹»ç¯ç‰‡å·²åœæ­¢ã€‚", 'info');
        }

        // --- æ¥æ”¶ç«¯é€»è¾‘ ---
        async function startScanning() {
            const privKeyHex = DOM.receiverPrivateKey.value.trim();
            if (!privKeyHex || !/^[0-9a-fA-F]{64}$/.test(privKeyHex)) {
                updateStatus(DOM.receiverStatus, "è¯·è¾“å…¥æœ‰æ•ˆçš„64ä½åå…­è¿›åˆ¶ç§é’¥ã€‚", 'error');
                return;
            }
            AppState.receiver.privateKey = privKeyHex;

            try {
                AppState.receiver.stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                DOM.videoPreview.srcObject = AppState.receiver.stream;
                DOM.videoPreview.style.display = 'inline-block';
                DOM.noCameraMsg.style.display = 'none';
                AppState.receiver.scanning = true;
                AppState.receiver.scanCount = 0;
                AppState.receiver.lastScanTime = performance.now();
                AppState.receiver.receivedChunks = {};
                updateStatus(DOM.receiverStatus, "æ‘„åƒå¤´å·²å¯åŠ¨ï¼Œå¼€å§‹æ‰«æ...", 'info');
                DOM.startScanBtn.disabled = true;
                DOM.stopScanBtn.disabled = false;
                scanLoop();
            } catch (err) {
                console.error("è®¿é—®æ‘„åƒå¤´å¤±è´¥:", err);
                updateStatus(DOM.receiverStatus, `æ‘„åƒå¤´é”™è¯¯: ${err.message}`, 'error');
            }
        }

        function stopScanning() {
            AppState.receiver.scanning = false;
            if (AppState.receiver.stream) {
                const tracks = AppState.receiver.stream.getTracks();
                tracks.forEach(track => track.stop());
                AppState.receiver.stream = null;
            }
            DOM.videoPreview.style.display = 'none';
            DOM.noCameraMsg.style.display = 'block';
            DOM.startScanBtn.disabled = false;
            DOM.stopScanBtn.disabled = true;
            updateStatus(DOM.receiverStatus, "æ‘„åƒå¤´å·²åœæ­¢ã€‚", 'info');
        }

        function scanLoop() {
            // --- æ·»åŠ æ£€æŸ¥ ---
            if (typeof jsQR === 'undefined') {
                console.error("jsQR library is not loaded. Scan loop cannot proceed.");
                stopScanning();
                updateStatus(DOM.receiverStatus, "jsQRåº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–åˆ·æ–°é¡µé¢ã€‚", 'error');
                return;
            }
            // --- ç»“æŸæ·»åŠ æ£€æŸ¥ ---

            if (!AppState.receiver.scanning) return;

            if (DOM.videoPreview.readyState === DOM.videoPreview.HAVE_ENOUGH_DATA) {
                const canvas = document.createElement('canvas');
                canvas.width = DOM.videoPreview.videoWidth;
                canvas.height = DOM.videoPreview.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(DOM.videoPreview, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const code = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: "dontInvert",
                });
                if (code) {
                    processScannedQR(code.data);
                }
            }
            requestAnimationFrame(scanLoop);
        }

        async function processScannedQR(qrDataStr) {
             try {
                const parsedData = parseQRData(qrDataStr);
                logDebug(`æ‰«æåˆ°å—: ${parsedData.fileId}${parsedData.index}`);

                // æ›´æ–°è¿›åº¦
                AppState.receiver.scanCount++;
                DOM.scannedCount.textContent = AppState.receiver.scanCount;

                // è®¡ç®—é€Ÿåº¦
                const now = performance.now();
                const elapsedSeconds = (now - AppState.receiver.lastScanTime) / 1000;
                if (elapsedSeconds > 1) {
                    const speedKbps = (AppState.receiver.scanCount * 50) / elapsedSeconds; // å‡è®¾50KB/å—
                    DOM.scanSpeed.textContent = speedKbps.toFixed(2);
                    AppState.receiver.lastScanTime = now;
                    AppState.receiver.scanCount = 0;
                }

                // å­˜å‚¨å—
                const fileId = parsedData.fileId;
                if (!AppState.receiver.receivedChunks[fileId]) {
                    AppState.receiver.receivedChunks[fileId] = { total: parsedData.total, chunks: {} };
                }
                // é¿å…é‡å¤å¤„ç†åŒä¸€ä¸ªå—
                if (!(parsedData.index in AppState.receiver.receivedChunks[fileId].chunks)) {
                    AppState.receiver.receivedChunks[fileId].chunks[parsedData.index] = {
                        dataB64: parsedData.dataB64,
                        ephemeralPubKeyHex: parsedData.ephemeralPubKeyHex,
                        fileHash: parsedData.fileHash
                    };

                    // æ›´æ–°è¿›åº¦æ¡
                    const totalReceived = Object.keys(AppState.receiver.receivedChunks[fileId].chunks).length;
                    const progressPercent = (totalReceived / parsedData.total) * 100;
                    DOM.scanProgressBar.style.width = `${progressPercent}%`;

                    // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å®Œæ•´
                    if (totalReceived === parsedData.total) {
                        await assembleFile(fileId);
                    }
                }

            } catch (error) {
                console.error("å¤„ç†æ‰«ææ•°æ®æ—¶å‡ºé”™:", error);
                updateStatus(DOM.receiverStatus, `å¤„ç†æ‰«ææ•°æ®æ—¶å‡ºé”™: ${error.message}`, 'error');
                // ä¸ä¸­æ–­æ‰«æå¾ªç¯
            }
        }

        async function assembleFile(fileId) {
            const fileInfo = AppState.receiver.receivedChunks[fileId];
            try {
                updateStatus(DOM.receiverStatus, `æ­£åœ¨ç»„è£…æ–‡ä»¶ ${fileId}...`, 'info');
                
                let fullBase64Content = '';
                let finalFileName = `received_file_${fileId}.dat`; // é»˜è®¤å
                let originalFileHash = ''; // ä»äºŒç»´ç è·å–çš„åŸå§‹å“ˆå¸Œ
                let calculatedFileHash = ''; // é‡ç»„åè®¡ç®—çš„å“ˆå¸Œ
                
                const sortedIndices = Object.keys(fileInfo.chunks).map(Number).sort((a, b) => a - b);
                
                // --- ä»ç¬¬ä¸€ä¸ªå—è§£å¯†å¹¶è·å–æ–‡ä»¶å…ƒæ•°æ® ---
                if (sortedIndices.length > 0) {
                    const firstChunk = fileInfo.chunks[sortedIndices[0]];
                    const firstDecryptedData = await decryptDataWithECC(
                        firstChunk.ephemeralPubKeyHex,
                        firstChunk.dataB64,
                        AppState.receiver.privateKey
                    );
                    // è§£æç¬¬ä¸€ä¸ªå—è§£å¯†åçš„æ•°æ®ï¼Œè·å–å…ƒæ•°æ®
                    const firstParts = firstDecryptedData.split('|');
                    if (firstParts.length < 2) {
                        throw new Error("ç¬¬ä¸€ä¸ªè§£å¯†å—æ•°æ®æ ¼å¼æ— æ•ˆï¼Œæ— æ³•è·å–æ–‡ä»¶å…ƒæ•°æ®ã€‚");
                    }
                    // ç¬¬ä¸€éƒ¨åˆ†æ˜¯æ•°æ®ï¼Œç¬¬äºŒéƒ¨åˆ†æ˜¯å…ƒæ•°æ® Base64
                    const metaDataB64 = firstParts[1];
                    const metaDataBytes = base64ToArrayBuffer(metaDataB64);
                    const metaDataString = new TextDecoder().decode(metaDataBytes);
                    const metaDataParts = metaDataString.split('|');
                    if (metaDataParts.length !== 4) {
                        throw new Error("è§£å¯†å¾—åˆ°çš„æ–‡ä»¶å…ƒæ•°æ®æ ¼å¼æ— æ•ˆã€‚");
                    }
                    const baseFileName = metaDataParts[0];
                    const fileExtension = metaDataParts[1];
                    originalFileHash = metaDataParts[2]; // è·å–åŸå§‹å“ˆå¸Œ
                    // const totalChunksFromMeta = parseInt(metaDataParts[3]); // å¯ç”¨äºéªŒè¯

                    finalFileName = fileExtension ? `${baseFileName}.${fileExtension}` : baseFileName;
                }
                // --- ç»“æŸ ---

                // --- è§£å¯†æ‰€æœ‰å—å¹¶æ‹¼æ¥æ–‡ä»¶æ•°æ® ---
                for (const index of sortedIndices) {
                    const chunk = fileInfo.chunks[index];
                    const decryptedChunkData = await decryptDataWithECC(
                        chunk.ephemeralPubKeyHex,
                        chunk.dataB64,
                        AppState.receiver.privateKey
                    );
                    // ä»è§£å¯†æ•°æ®ä¸­æå–æ–‡ä»¶å†…å®¹éƒ¨åˆ† (ç¬¬ä¸€éƒ¨åˆ†)
                    const dataParts = decryptedChunkData.split('|');
                    if (dataParts.length < 1) {
                        throw new Error(`è§£å¯†å— ${index} æ•°æ®æ ¼å¼æ— æ•ˆã€‚`);
                    }
                    const chunkBase64Data = dataParts[0];
                    fullBase64Content += chunkBase64Data;
                }
                // --- ç»“æŸ ---

                const byteCharacters = atob(fullBase64Content);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                const blob = new Blob([byteArray]);

                // --- ä½¿ç”¨ä»å…ƒæ•°æ®ä¸­è·å–çš„æ–‡ä»¶å ---
                // finalFileName å·²åœ¨ä¸Šé¢è®¾ç½®
                calculatedFileHash = await calculateSHA256(blob); // é‡æ–°è®¡ç®—ä»¥éªŒè¯

                // ä¿å­˜åˆ° localStorage (å…ƒæ•°æ®) å’Œ IndexedDB (æ–‡ä»¶å†…å®¹)
                const fileMeta = {
                    name: finalFileName, // ä½¿ç”¨æ­£ç¡®çš„æ–‡ä»¶å
                    size: blob.size,
                    sha256: calculatedFileHash, // å­˜å‚¨è®¡ç®—å‡ºçš„å“ˆå¸Œ
                    originalSha256: originalFileHash, // ä¹Ÿå­˜å‚¨åŸå§‹å“ˆå¸Œä¾›æ¯”å¯¹
                    timestamp: Date.now()
                };
                let receivedMeta = JSON.parse(localStorage.getItem('received_files_meta') || '{}');
                receivedMeta[fileId] = fileMeta;
                localStorage.setItem('received_files_meta', JSON.stringify(receivedMeta));

                // ä¿å­˜æ–‡ä»¶å†…å®¹åˆ° IndexedDB
                await saveFileToIDB(fileId, blob);

                // --- æ˜¾ç¤ºå“ˆå¸Œå€¼å¯¹æ¯” ---
                const hashMatch = originalFileHash === calculatedFileHash;
                const hashMessage = hashMatch ? 
                    `<p style="color:green;">âœ… å“ˆå¸Œå€¼åŒ¹é…ï¼æ–‡ä»¶å®Œæ•´æ€§å·²éªŒè¯ã€‚</p>` : 
                    `<p style="color:red;">âŒ å“ˆå¸Œå€¼ä¸åŒ¹é…ï¼æ–‡ä»¶å¯èƒ½å·²æŸåæˆ–è¢«ç¯¡æ”¹ã€‚<br>åŸå§‹: ${originalFileHash}<br>è®¡ç®—: ${calculatedFileHash}</p>`;
                
                updateStatus(DOM.receiverStatus, `æ–‡ä»¶ ${finalFileName} æ¥æ”¶å¹¶ä¿å­˜æˆåŠŸ! ${hashMessage}`, 'success');
                updateReceivedFilesList();
                logDebug(`æ–‡ä»¶ ${finalFileName} ç»„è£…å¹¶ä¿å­˜æˆåŠŸã€‚`);

            } catch (e) {
                console.error(`ç»„è£…æ–‡ä»¶ ${fileId} æ—¶å‡ºé”™:`, e);
                updateStatus(DOM.receiverStatus, `ç»„è£…æ–‡ä»¶ ${fileId} å¤±è´¥: ${e.message}`, 'error');
            }
        }

        async function downloadReceivedFile(fileId) {
            try {
                const blob = await getFileFromIDB(fileId);
                if (!blob) {
                    alert("æ–‡ä»¶æœªæ‰¾åˆ°!");
                    return;
                }
                
                const meta = JSON.parse(localStorage.getItem('received_files_meta') || '{}')[fileId];
                const filename = meta ? meta.name : `file_${fileId}`;

                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                logDebug(`æ–‡ä»¶ ${fileId} å·²è§¦å‘ä¸‹è½½ã€‚`);
            } catch (e) {
                console.error("ä¸‹è½½æ–‡ä»¶æ—¶å‡ºé”™:", e);
                alert("ä¸‹è½½å¤±è´¥: " + e.message);
            }
        }


        // --- IndexedDB æ–‡ä»¶å­˜å‚¨ ---
        const DB_NAME = 'QRFileTransferDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'files';

        function openIDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                };
            });
        }

        async function saveFileToIDB(id, blob) {
            const db = await openIDB();
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            return new Promise((resolve, reject) => {
                const request = store.put({ id, blob });
                request.onsuccess = () => {
                    db.close();
                    resolve();
                };
                request.onerror = () => {
                    db.close();
                    reject(request.error);
                };
            });
        }

        async function getFileFromIDB(id) {
            const db = await openIDB();
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            return new Promise((resolve, reject) => {
                const request = store.get(id);
                request.onsuccess = () => {
                    db.close();
                    resolve(request.result ? request.result.blob : null);
                };
                request.onerror = () => {
                    db.close();
                    reject(request.error);
                };
            });
        }

        // --- åŠ å¯†/è§£å¯†é€»è¾‘ (ä½¿ç”¨ elliptic åº“) ---
        const CURVE_NAME = 'p256'; // secp256r1
        const SYMMETRIC_ALGORITHM = 'AES-GCM';
        const IV_LENGTH = 12;
        const SALT = new TextEncoder().encode("QR_FILE_TRANSFER_SALT");

        function loadECCPrivateKey(privKeyHex) {
            if (!window.elliptic) throw new Error("Elliptic library not loaded.");
            const EC = window.elliptic.ec;
            const ec = new EC(CURVE_NAME);
            return ec.keyFromPrivate(privKeyHex, 'hex');
        }

        function deriveSharedSecret(privateKeyPair, publicKeyHex) {
            if (!window.elliptic) throw new Error("Elliptic library not loaded.");
            const EC = window.elliptic.ec;
            const ec = new EC(CURVE_NAME);
            const peerPublicKey = ec.keyFromPublic(publicKeyHex, 'hex');
            const sharedPoint = peerPublicKey.getPublic().mul(privateKeyPair.getPrivate());
            const sharedX = sharedPoint.getX();
            const sharedSecretHex = sharedX.toString(16, 64);
            return hexStringToArrayBuffer(sharedSecretHex);
        }

        async function deriveSymmetricKey(sharedSecretBuffer) {
            const sharedSecretKey = await crypto.subtle.importKey('raw', sharedSecretBuffer, { name: 'HKDF' }, false, ['deriveKey']);
            return await crypto.subtle.deriveKey(
                { name: 'HKDF', hash: 'SHA-256', salt: SALT, info: new TextEncoder().encode("key") },
                sharedSecretKey,
                { name: SYMMETRIC_ALGORITHM, length: 256 },
                true, ['encrypt', 'decrypt']
            );
        }

        async function encryptDataWithECC(dataToEncrypt, masterPrivateKeyHex) {
            if (!window.elliptic) throw new Error("Elliptic library not found.");
            const EC = window.elliptic.ec;
            const ec = new EC(CURVE_NAME);

            const ephemeralKeyPair = ec.genKeyPair();
            const ephemeralPublicKeyHex = ephemeralKeyPair.getPublic(true, 'hex'); // Compressed

            const masterKeyPair = loadECCPrivateKey(masterPrivateKeyHex);
            // ECDH: shared secret = ephemeral private key * master public key
            // But for decryption, we use master private key * ephemeral public key
            // Which yields the same shared secret point.
            const sharedSecretBuffer = deriveSharedSecret(ephemeralKeyPair, masterKeyPair.getPublic(true, 'hex'));
            const symmetricKey = await deriveSymmetricKey(sharedSecretBuffer);

            const iv = crypto.getRandomValues(new Uint8Array(IV_LENGTH));
            const encodedData = new TextEncoder().encode(dataToEncrypt);
            const encryptedContent = await crypto.subtle.encrypt({ name: SYMMETRIC_ALGORITHM, iv: iv }, symmetricKey, encodedData);

            const combinedBuffer = new Uint8Array(iv.length + encryptedContent.byteLength);
            combinedBuffer.set(iv, 0);
            combinedBuffer.set(new Uint8Array(encryptedContent), iv.length);
            const encryptedDataB64 = arrayBufferToBase64(combinedBuffer);

            return { encryptedDataB64, ephemeralPublicKeyHex };
        }

        async function decryptDataWithECC(ephemeralPublicKeyHex, encryptedDataB64, masterPrivateKeyHex) {
            if (!window.elliptic) throw new Error("Elliptic library not found.");

            const masterKeyPair = loadECCPrivateKey(masterPrivateKeyHex);
            // ECDH: shared secret = master private key * ephemeral public key
            const sharedSecretBuffer = deriveSharedSecret(masterKeyPair, ephemeralPublicKeyHex);
            const symmetricKey = await deriveSymmetricKey(sharedSecretBuffer);

            const combinedBuffer = base64ToArrayBuffer(encryptedDataB64);
            const iv = combinedBuffer.slice(0, IV_LENGTH);
            const encryptedData = combinedBuffer.slice(IV_LENGTH);

            const decryptedContent = await crypto.subtle.decrypt({ name: SYMMETRIC_ALGORITHM, iv: iv }, symmetricKey, encryptedData);
            return new TextDecoder().decode(decryptedContent);
        }

        // --- å·¥å…·å‡½æ•° ---
        async function calculateSHA256(data) {
            const buffer = data instanceof ArrayBuffer ? data : await new Blob([data]).arrayBuffer();
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();
        }

        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binary_string = atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function splitString(str, chunkSize) {
            const chunks = [];
            for (let i = 0; i < str.length; i += chunkSize) {
                chunks.push(str.slice(i, i + chunkSize));
            }
            return chunks;
        }

        // æ ¹æ®æ–‡æ¡£æ ¼å¼åŒ–äºŒç»´ç æ•°æ®
        // æ ¼å¼: <EPHEMERAL_PUBKEY_HEX>-<ENCRYPTED_DATA_B64>-<CHUNK_ID>-<FILE_SHA256>-<TOTAL>
        function formatQRData(dataToEncryptB64, fileId, index, total, ephemeralPubKeyHex, fileHash) {
            const chunkId = `${fileId}${index}`;
            return `${ephemeralPubKeyHex}-${dataToEncryptB64}-${chunkId}-${fileHash}-${total}`;
        }

        // è§£ææ ¼å¼åŒ–çš„äºŒç»´ç æ•°æ®å­—ç¬¦ä¸²
        // æ ¼å¼: <EPHEMERAL_PUBKEY_HEX>-<ENCRYPTED_DATA_B64>-<CHUNK_ID>-<FILE_SHA256>-<TOTAL>
        function parseQRData(qrDataStr) {
            const parts = qrDataStr.split('-');
            if (parts.length < 5) throw new Error("äºŒç»´ç æ•°æ®æ ¼å¼æ— æ•ˆ");
            const ephemeralPubKeyHex = parts[0];
            const dataB64 = parts[1];
            const chunkId = parts[2];
            const fileHash = parts[3];
            const totalStr = parts[4];

            const match = chunkId.match(/^([A-Y])(\d+)$/);
            if (!match) throw new Error("å— ID æ ¼å¼æ— æ•ˆ");
            const fileId = match[1];
            const index = parseInt(match[2], 10);

            return { ephemeralPubKeyHex, dataB64, fileId, index, fileHash, total: parseInt(totalStr, 10) };
        }

        function hexStringToArrayBuffer(hexString) {
            if (hexString.length % 2 !== 0) throw new Error("Hex string must have an even number of characters");
            const length = hexString.length / 2;
            const buffer = new ArrayBuffer(length);
            const view = new Uint8Array(buffer);
            for (let i = 0; i < length; i++) {
                view[i] = parseInt(hexString.substr(i * 2, 2), 16);
            }
            return buffer;
        }

        function clearAllStorage() {
            if (confirm("âš ï¸ è­¦å‘Š: è¿™å°†æ¸…é™¤æ‰€æœ‰æœ¬åœ°æ•°æ®(å¯†é’¥ã€å·²æ”¶æ–‡ä»¶ç­‰)ã€‚ç¡®å®šå—?")) {
                localStorage.clear();
                // Clear IndexedDB
                const deleteReq = indexedDB.deleteDatabase(DB_NAME);
                deleteReq.onsuccess = () => {
                    alert("æ‰€æœ‰æœ¬åœ°æ•°æ®å·²æ¸…é™¤ã€‚");
                    location.reload(); // é‡æ–°åŠ è½½é¡µé¢ä»¥é‡ç½®åº”ç”¨çŠ¶æ€
                };
                deleteReq.onerror = () => {
                    alert("æ¸…é™¤ IndexedDB æ—¶å‡ºé”™ã€‚");
                };
            }
        }

        // --- æ–°å¢ï¼šå¤„ç†ä¸Šä¼ çš„äºŒç»´ç å›¾ç‰‡ ---
        async function handleQrImageUpload() {
            const files = DOM.qrImageUpload.files;
            if (files.length === 0) {
                updateStatus(DOM.uploadQrStatus, "è¯·é€‰æ‹©è‡³å°‘ä¸€ä¸ªå›¾ç‰‡æ–‡ä»¶ã€‚", 'error');
                return;
            }

            updateStatus(DOM.uploadQrStatus, `æ­£åœ¨å¤„ç† ${files.length} ä¸ªå›¾ç‰‡æ–‡ä»¶...`, 'info');
            DOM.processQrImagesBtn.disabled = true;

            let processedCount = 0;
            let successCount = 0;

            try {
                for (const file of files) {
                    processedCount++;
                    updateStatus(DOM.uploadQrStatus, `æ­£åœ¨å¤„ç† (${processedCount}/${files.length}): ${file.name}...`, 'info');

                    try {
                        const dataUrl = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = e => resolve(e.target.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(file);
                        });

                        // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ Image å¯¹è±¡æ¥è·å–å°ºå¯¸
                        const img = new Image();
                        const imgLoadPromise = new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = reject;
                            img.src = dataUrl;
                        });

                        await imgLoadPromise;

                        // åˆ›å»º canvas å¹¶ç»˜åˆ¶å›¾ç‰‡
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0, img.width, img.height);

                        // è·å–å›¾åƒæ•°æ®å¹¶ä½¿ç”¨ jsQR è§£ç 
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height);

                        if (code) {
                            successCount++;
                            logDebug(`ä»å›¾ç‰‡ ${file.name} æˆåŠŸè§£ç äºŒç»´ç : ${code.data}`);
                            // å¤ç”¨å·²æœ‰çš„ processScannedQR å‡½æ•°æ¥å¤„ç†è§£ç åçš„æ•°æ®
                            await processScannedQR(code.data);
                        } else {
                            logDebug(`æœªèƒ½ä»å›¾ç‰‡ ${file.name} è§£ç å‡ºäºŒç»´ç ã€‚`);
                            updateStatus(DOM.uploadQrStatus, `æœªèƒ½ä»å›¾ç‰‡ ${file.name} è§£ç å‡ºäºŒç»´ç ã€‚`, 'error');
                        }
                    } catch (e) {
                        console.error(`å¤„ç†å›¾ç‰‡ ${file.name} æ—¶å‡ºé”™:`, e);
                        updateStatus(DOM.uploadQrStatus, `å¤„ç†å›¾ç‰‡ ${file.name} æ—¶å‡ºé”™: ${e.message}`, 'error');
                    }
                }

                updateStatus(DOM.uploadQrStatus, `å¤„ç†å®Œæˆã€‚å…±å¤„ç† ${files.length} ä¸ªæ–‡ä»¶ï¼ŒæˆåŠŸè§£ç  ${successCount} ä¸ªã€‚`, 'success');

            } finally {
                DOM.processQrImagesBtn.disabled = false;
            }
        }
        // --- ç»“æŸæ–°å¢ ---


        // --- åˆå§‹åŒ– ---
        function initApp() {
            console.log("åº”ç”¨åˆå§‹åŒ–...");
            
            // ç»‘å®šäº‹ä»¶ (ç›´æ¥åœ¨ DOM å…ƒç´ ä¸Šç»‘å®šäº† onclickï¼Œè¿™é‡Œç»‘å®šå…¶ä»–äº‹ä»¶)
            DOM.processBtn.addEventListener('click', handleProcessFiles);
            DOM.startSlideshowBtn.addEventListener('click', startSlideshow);
            DOM.stopSlideshowBtn.addEventListener('click', stopSlideshow);

            DOM.startScanBtn.addEventListener('click', startScanning);
            DOM.stopScanBtn.addEventListener('click', stopScanning);

            DOM.saveKeyBtn.addEventListener('click', saveKey);
            DOM.clearKeysBtn.addEventListener('click', clearAllKeys);

            DOM.clearStorageBtn.addEventListener('click', clearAllStorage);

            // --- æ–°å¢äº‹ä»¶ç›‘å¬ ---
            DOM.processQrImagesBtn.addEventListener('click', handleQrImageUpload);
            // --- ç»“æŸæ–°å¢ ---

            // è‡ªåŠ¨å¡«å……å¯†é’¥é€‰æ‹©æ¡†
            DOM.senderPrivateKeySelect.addEventListener('change', function() {
                const keyName = this.value;
                if (keyName && AppState.keys[keyName]) {
                    DOM.senderPrivateKey.value = AppState.keys[keyName].value;
                    AppState.sender.privateKey = AppState.keys[keyName].value;
                }
            });
            DOM.receiverPrivateKeySelect.addEventListener('change', function() {
                const keyName = this.value;
                if (keyName && AppState.keys[keyName]) {
                    DOM.receiverPrivateKey.value = AppState.keys[keyName].value;
                    AppState.receiver.privateKey = AppState.keys[keyName].value;
                }
            });

            populateKeySelects();
            populateKeyIndexSelect();
            updateStoredKeysList();
            updateSentFilesList();
            updateReceivedFilesList();
            updateStorageInfo();
            
            logDebug("åº”ç”¨åˆå§‹åŒ–å®Œæˆã€‚");
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>